# BSC合约信息播报机制说明（无缓存版本）

本文档详细说明BSC合约信息播报的工作原理。

## 概述

机器人使用**防刷屏 + 100%实时数据**的机制，既能防止短时间内的重复播报，又能确保每次播报都是API直接获取的最新数据。

## 工作机制

### 1. 防刷屏机制（addressCache）

**位置：** `messageHandler.js`
**配置：** `CACHE_ADDRESS_TIMEOUT`（默认10秒）

**作用：**
- 防止同一地址在短时间内被重复播报
- 避免群消息被刷屏

**工作原理：**
```
时间线：
T0秒: 用户A发送地址 0x123... → 立即播报 ✅
T3秒: 用户B发送地址 0x123... → 跳过（缓存中）❌
T8秒: 用户C发送地址 0x123... → 跳过（缓存中）❌
T12秒: 用户D发送地址 0x123... → 重新播报（缓存已过期）✅
```

### 2. 实时数据获取（无缓存）

**位置：** `aveApiV2.js`
**实现：** 完全不使用缓存，直接调用API

**作用：**
- 每次播报都直接调用 Ave.ai API
- 确保获取最新的价格、涨跌幅等数据
- 100%实时，无缓存延迟

**关键实现：**
```javascript
async getTokenInfo(tokenAddress) {
  // 不使用缓存，每次都直接调用API获取最新数据
  this.logger.debug(`获取最新代币信息（不使用缓存）: ${tokenAddress}`);

  // 直接调用API
  const response = await axios.get(...);

  // 不缓存，直接返回
  return tokenInfo;
}
```

## 实际场景示例

### 场景1：防刷屏

```
10:00:00 - 用户A: "看看这个币 0xAAA..."
10:00:01 - 机器人: 调用API，播报最新信息 ✅
           价格: $0.001, 涨幅: +10%

10:00:03 - 用户B: "这个币怎么样 0xAAA..."
10:00:03 - 机器人: 跳过（3秒前刚播报过）❌

10:00:08 - 用户C: "关注一下 0xAAA..."
10:00:08 - 机器人: 跳过（8秒前刚播报过）❌
```

**结果：** 10秒内只播报1次，避免刷屏 🎯

### 场景2：实时数据

```
10:00:00 - 用户A: "看看这个币 0xAAA..."
10:00:01 - 机器人: 调用API，播报 ✅
           价格: $0.001, 涨幅: +10%

[币价上涨...]

10:00:15 - 用户B: "这个币现在怎么样 0xAAA..."
10:00:15 - 机器人: 再次调用API，播报最新数据 ✅
           价格: $0.0015, 涨幅: +50%
```

**结果：** 超过10秒后，获取最新数据并播报 🔄
**关键：** 第二次播报的数据是重新调用API获取的，不是缓存！

## 核心代码

### messageHandler.js

```javascript
async processContractAddress(room, address) {
  const cacheKey = `broadcast:${normalizedAddress}`;

  // 检查防刷屏机制
  if (this.addressCache.has(cacheKey)) {
    this.logger.debug(`地址已在缓存中，跳过`);
    return;  // 不播报
  }

  // 直接调用API获取最新数据（不使用任何缓存）
  const tokenInfo = await this.tokenApiService.getTokenInfo(address);

  // 播报
  await room.say(formattedMessage);

  // 记录到防刷屏缓存
  this.addressCache.set(cacheKey, true);
}
```

### aveApiV2.js

```javascript
async getTokenInfo(tokenAddress) {
  // 不使用缓存，每次都直接调用API获取最新数据
  this.logger.debug(`获取最新代币信息（不使用缓存）: ${tokenAddress}`);

  // 检查速率限制
  if (!this.rateLimiter.canMakeRequest()) {
    await this.delay(waitTime);
  }

  // 直接调用API
  const response = await axios.get(`${this.baseUrl}/v2/tokens`, {
    params: { keyword: tokenAddress },
    headers: { 'X-API-KEY': this.apiKey }
  });

  // 直接返回，不缓存
  return this.processTokenData(response.data.data);
}
```

## 优势

### ✅ 1. 防止刷屏
- 同一地址在短时间内不会被重复播报
- 避免群聊被大量相同信息占据

### ✅ 2. 100%实时数据
- 每次播报都直接调用API
- 确保用户看到的是当前最新的价格和涨跌幅
- 无缓存延迟，数据100%准确

### ✅ 3. API调用可控
- 防刷屏机制大幅减少了API调用次数
- 速率限制保护避免超出API限额
- 同一地址10秒内只调用1次API

### ✅ 4. 代码简单
- 移除了复杂的缓存逻辑
- 不需要处理 `forceRefresh` 参数
- 代码更易理解和维护

## 配置说明

### CACHE_ADDRESS_TIMEOUT（防刷屏时间）

**推荐值：**
- **活跃群聊：** 10000ms（10秒）- 默认值 ✅
- **低频群聊：** 5000ms（5秒）
- **高频群聊：** 15000ms（15秒）

**配置方法：**
```env
# .env 文件
CACHE_ADDRESS_TIMEOUT=10000  # 10秒内不重复播报
```

**注意：**
- 设置过短可能导致刷屏
- 设置过长可能让用户等待时间过长
- 推荐使用默认值10秒

## API调用频率分析

### 场景分析

假设一个活跃群，50个用户，每小时发送100个合约地址：

**情况1：所有地址都不同**
- API调用次数：100次/小时
- 平均：1.67次/分钟
- 评估：完全可控 ✅

**情况2：50%地址重复（热门币）**
- 防刷屏拦截：50次
- API调用次数：50次/小时
- 平均：0.83次/分钟
- 评估：非常理想 ✅

**情况3：同一地址被反复发送**
- 防刷屏机制生效
- 每10秒最多调用1次
- 每小时最多：6次 × 60分钟 = 360次
- 实际场景中不会达到这个极限
- 评估：API压力可控 ✅

## 监控和调试

### 查看实时数据获取

启用调试日志：
```env
LOG_LEVEL=debug
```

日志输出示例：
```
[DEBUG] 获取最新代币信息（不使用缓存）: 0x123...
[INFO ] 获取代币信息 [0x123...] (尝试 1/3)
[INFO ] 成功获取最新代币信息: 0x123...
[INFO ] ✓ 合约信息已播报
```

### 关键日志含义

| 日志 | 含义 |
|------|------|
| `获取最新代币信息（不使用缓存）` | 准备调用API |
| `获取代币信息 [地址] (尝试 1/3)` | 正在调用API |
| `成功获取最新代币信息` | API调用成功 |
| `地址已在缓存中，跳过` | 防刷屏生效 |

## 常见问题

### Q: 完全不缓存会不会导致API调用过多？

A: **不会！** 原因：
- 防刷屏机制：同一地址10秒内只调用1次API
- 速率限制：有全局的速率限制保护
- 实际测试：即使活跃群聊，API调用也完全可控
- 优先级：数据准确性 > API调用次数

### Q: 如何验证每次都是最新数据？

A: 简单验证方法：
1. 启用调试日志：`LOG_LEVEL=debug`
2. 发送一个地址，查看价格
3. 等待10秒后再次发送
4. 查看日志中的"获取最新代币信息（不使用缓存）"
5. 对比两次价格是否有变化

### Q: 防刷屏时间过期后，一定会调用API吗？

A: **100%确定！** 流程：
1. 检查 addressCache → 不存在
2. 直接调用 `getTokenInfo(address)`
3. API方法内部没有任何缓存检查
4. 直接发起HTTP请求到Ave.ai
5. 返回最新数据并播报

### Q: 速率限制会影响实时性吗？

A: **不会！** 原因：
- 速率限制默认：30请求/分钟
- 防刷屏机制已经控制了频率
- 正常使用不会触发速率限制
- 即使触发，也只是等待几秒，不影响播报

### Q: 相比有缓存的版本，优势是什么？

A: **简单 + 可靠**：
- ✅ 无缓存逻辑，代码简单
- ✅ 无缓存问题，不会出现旧数据
- ✅ 100%实时，用户信任度高
- ✅ 易于调试，日志清晰
- ✅ 无需担心缓存未清理等问题

## 最佳实践

### 推荐配置（活跃群）

```env
CACHE_ADDRESS_TIMEOUT=10000    # 10秒防刷屏
MIN_QUERY_INTERVAL=0           # 无额外限制
MAX_REQUESTS_PER_MINUTE=30     # 速率限制
LOG_LEVEL=info                 # 正常日志
```

### 推荐配置（低频群）

```env
CACHE_ADDRESS_TIMEOUT=5000     # 5秒防刷屏
MIN_QUERY_INTERVAL=0           # 无额外限制
MAX_REQUESTS_PER_MINUTE=30     # 速率限制
LOG_LEVEL=info                 # 正常日志
```

### 调试配置

```env
CACHE_ADDRESS_TIMEOUT=3000     # 3秒（方便测试）
LOG_LEVEL=debug                # 详细日志
```

## 版本对比

### V1.0 - 使用API缓存

❌ API数据缓存10分钟
❌ 用户看到旧数据
❌ 币价波动时信息不准

### V2.0 - 强制刷新

⚠️ 使用 `forceRefresh` 参数
⚠️ 逻辑复杂，容易出错
⚠️ 缓存管理繁琐

### V3.0 - 无缓存（当前版本）

✅ 完全移除API缓存
✅ 每次直接调用API
✅ 100%实时数据
✅ 代码简单清晰
✅ 防刷屏保护API

## 总结

当前机制的核心优势：

🛡️ **防刷屏** - 10秒内不重复播报同一地址
💯 **100%实时** - 每次播报都是API实时数据
⚡ **API可控** - 防刷屏机制控制调用频率
🎯 **简单可靠** - 无缓存逻辑，无缓存问题
✨ **用户信任** - 数据准确，用户满意度高

---

**设计原则：**
- 简单 > 复杂
- 准确 > 性能
- 可靠 > 优化

**适用场景：**
- ✅ 所有场景（无例外）
- ✅ 活跃群（防刷屏生效）
- ✅ 低频群（实时数据）
- ✅ 快速波动币（准确信息）

**推荐指数：** ⭐⭐⭐⭐⭐ 强烈推荐！
